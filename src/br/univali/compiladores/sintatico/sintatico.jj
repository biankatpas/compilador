options{
    STATIC = false;
    IGNORE_CASE = true;
}

PARSER_BEGIN(Parser)
package br.univali.compiladores.sintatico;
import java.util.ArrayList;
import java.util.List;
import java.io.StringReader;

public class Parser {
	int contParseError = 0;
	boolean debugRecovery = true;
        final static List<Integer> errorLexList = new ArrayList<Integer>();
        final static List<Message> output = new ArrayList<Message>();

        public Parser() {
            errorLexList.add(ParserConstants.IDENTIFICADOR_INVALIDO);
            errorLexList.add(ParserConstants.SIMBOLO_INVALIDO);
            errorLexList.add(ParserConstants.CONSTANTE_NUM_INTEIRA_INVALIDA);
            errorLexList.add(ParserConstants.CONSTANTE_NUM_REAL_INVALIDA);
            errorLexList.add(ParserConstants.CONSTANTE_LITERAL_INVALIDA);
        };

        public List<Message> lexicalAnalizer(String code){
            Parser lexicalParser = new Parser();

            try{
                lexicalParser = new Parser(new StringReader(code));
                lexicalParser.program();
            } catch(Exception e){
                output.add(new Message(e.toString(), true));
            } finally{
                output.add(new Message("Erros Lexicos encontrados: " + lexicalParser.token_source.countLexError, false));
                output.add(new Message("Erros Sintaticos encontrados: " + lexicalParser.contParseError, false));

                if(lexicalParser.token_source.countLexError == 0 && contParseError == 0){
                    output.add(new Message("Arquivo analisado com sucesso!", false));
                }
            }
            
            List<Message> auxList = new ArrayList<Message>(output);
            output.clear();
            return auxList;
        }

	public void setDebugRecovery(boolean debugRecovery) {
		this.debugRecovery = debugRecovery;
	}

	static public String im(int x) {
		int k;
		String s;
		s = tokenImage[x];
		k = s.lastIndexOf("\"");
		try {
			s = s.substring(1, k);
		} catch (StringIndexOutOfBoundsException e) {

		}
		return s;
	}

	boolean eof;
	void consumeUntil(RecoverySet g,
					  ParseException e,
					  String met) throws ParseException {
		
		Token tok;
                
		if (debugRecovery) {
			System.out.println();
			System.out.println("*** " + met + " ***");
			System.out.println("Synchronizing Set: " + g);
		}

		if (g == null) throw e;

		tok = getToken(1);
		
		while (!eof) {
			if (g.contains(tok.kind)) {
				if (debugRecovery) {
					System.out.println("Found synchronizing token: " + im(tok.kind));
				}
				break;
			}
			if (debugRecovery) {
				System.out.println("Ignoring token: " + im(tok.kind));
			}

			getNextToken();
			tok = getToken(1);
			
			if (tok.kind == EOF && !g.contains(EOF)) {
				eof = true;
			}
		}
		if (debugRecovery) {
			System.out.println(e.getMessage());
		}
		// FILTRO PARA NAO CONTAR ERROS LEXICOS COMO SINTATICOS
                if (!errorLexList.contains(e.currentToken.next.kind)) {
                    contParseError++;
                }
		if (eof) throw new ParseException("EOF Found prematurely.");
	}
}
PARSER_END(Parser)

TOKEN_MGR_DECLS : {
    int countLexError = 0;

    public int foundLexError() {
        return countLexError;
    }   
}

void program() : {} {
    try {
        [ begin_program() ]<EOF>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void type() : {}
{
	<INTEGER> | <REAL> | <STRING> | <LOGIC>
}

void value() : {} 
{
	<INTEGER> | <REAL> | <STRING>
}

void begin_program() throws ParseException: 
{
    RecoverySet g = new RecoverySet(EOF);
}
{
    try{
        <DO> <THIS> <IDENTIFICADOR> <OPENBRACKET> <CLOSEBRACKET> declarations() body(g) (description())?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void description() throws ParseException:
{}
{
    try {
        comment() 
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comment() : {}
{
	<CONSTANTE_LITERAL>
}

void declarations() throws ParseException:
{}
{
    try {
        ( <DECLARATION> declarations_() ) ?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void declarations_() throws ParseException:
{}
{
    try{
        (declaracao_tipo_enumerado() declaracao_tipo_enumerado_()) | declaracao_constantes_variaveis()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void declaracao_tipo_enumerado() throws ParseException:
{}
{
    try {
        <TYPE> <OPENBRACKET> identificadores_constantes() <DOT> <CLOSEBRACKET>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void declaracao_tipo_enumerado_() throws ParseException:
{}
{
    try {
        ( <DECLARATION> declaracao_constantes_variaveis() )?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void identificadores_constantes() throws ParseException:
{}
{
    try {
        constante() identificadores_constantes_()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void identificadores_constantes_() throws ParseException:
{}
{
    try {
        (identificadores_constantes())?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void constante() throws ParseException:
{}
{
    try {
        <IDENTIFICADOR> <IS> lista_identificadores_constante()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_identificadores_constante() throws ParseException:
{}
{
    try {
        <IDENTIFICADOR> lista_identificadores_constante_()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_identificadores_constante_() throws ParseException:
{}
{
    try {
        (<COMMA> <IDENTIFICADOR> lista_identificadores_constante__())?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_identificadores_constante__() throws ParseException:
{}
{
    try {
        lista_identificadores_constante_()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void declaracao_constantes_variaveis() throws ParseException:
{}
{
    try {
        <CONSTANT> <AND> <VARIABLE> <OPENBRACKET> constantes_variaveis() <CLOSEBRACKET>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void constantes_variaveis() throws ParseException:
{}
{
    try {
        (<AS> constantes_variaveis_())?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void constantes_variaveis_() throws ParseException:
{}
{
    try {
        ( bloco_constante() constante_() ) | ( bloco_variavel() variavel_() )
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void constante_() throws ParseException:
{}
{
    try {
        ( <AS> bloco_variavel() ) ?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void variavel_() throws ParseException:
{}
{
    try {
        ( <AS> bloco_constante() ) ?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void bloco_constante() throws ParseException:
{}
{
    try {
        <CONSTANT> declaracao_constante() bloco_constante_()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void bloco_constante_() throws ParseException:
{}
{
    try {
        ( declaracao_constante() ) *
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void declaracao_constante() throws ParseException:
{}
{
    try {
        lista_identificadores_constante() <IS> type() <ASSIGNMENT> value() <DOT>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void bloco_variavel() throws ParseException:
{}
{
    try {
        <VARIABLE> declaracao_variavel() bloco_variavel_()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void bloco_variavel_() throws ParseException:
{}
{
    try {
        ( declaracao_variavel() ) *
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void declaracao_variavel() throws ParseException:
{}
{
    try {
        lista_identificadores_variavel() <IS> type() <DOT>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_identificadores_variavel() throws ParseException:
{}
{
    try {
        <IDENTIFICADOR> lista_identificadores_variavel_()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_identificadores_variavel_() throws ParseException:
{}
{
    try {
        ( <COMMA> <IDENTIFICADOR>
        lista_identificadores_variavel__() |
        <OPENBRACKET><CONSTANTE_NUM_INTEIRA><CLOSEBRACKET> lista_identificadores_variavel__()
     ) ?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_identificadores_variavel__() throws ParseException:
{}
{
    try {
        lista_identificadores_variavel_()
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void body(RecoverySet g) throws ParseException:
{}
{
    try {
        <BODY> <OPENBRACKET> lista_comandos(g) <CLOSEBRACKET>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_comandos(RecoverySet g) throws ParseException:
{}
{
    try {
        comando(g) lista_comandos_(g)
  } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando(RecoverySet g) throws ParseException:
{}
{
    try {
        comando_atribuicao(g) | comando_entrada_dados(g) | comando_saida_dados(g) | comando_selecao(g)
  } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_comandos_(RecoverySet g) throws ParseException:
{}
{
    try {
        lista_comandos(g) |
        {}
  } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando_atribuicao(RecoverySet g) throws ParseException:
{}
{
    try {
        <DESIGNATE> <THIS> lista_identificadores_variavel() <TO> expression(g) <DOT>
    } catch (ParseException e) {
        consumeUntil(g, e, "comando_atribuicao");
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando_entrada_dados(RecoverySet g) throws ParseException:
{}
{
    try {
        <READ> <THIS> <OPENBRACKET> lista_identificadores_variavel() <CLOSEBRACKET> <DOT>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando_saida_dados(RecoverySet g) throws ParseException:
{}
{
    try {
        <WRITE> comando_saida_dados_() <DOT>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando_saida_dados_() throws ParseException:
{}
{
    try {
        (<ALL> comando_saida_dados__()) | comando_saida_dados__()
  } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando_saida_dados__() throws ParseException:
{}
{
    try {
        <THIS> <OPENBRACKET> lista_identificadores_constantes() <CLOSEBRACKET>
  } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void lista_identificadores_constantes() : {} {
    <IDENTIFICADOR>(<OPENBRACKET><CONSTANTE_NUM_INTEIRA><CLOSEBRACKET>)?  lista_identificadores_constantes_() |
    <CONSTANTE_NUM_INTEIRA> lista_identificadores_constantes_()|
    <CONSTANTE_NUM_REAL> lista_identificadores_constantes_()|
    <CONSTANTE_LITERAL>lista_identificadores_constantes_()
}

void lista_identificadores_constantes_() : {} {
    (<COMMA> lista_identificadores_constantes())?
}

void comando_selecao(RecoverySet g) throws ParseException:
{}
{
    try {
        <AVALIATE> <THIS> expression(g) comando_selecao_(g) <DOT>
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando_selecao_(RecoverySet g) throws ParseException:
{}
{
    try {
        selecao_true(g) | selecao_untrue(g)
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void selecao_true(RecoverySet g) throws ParseException:
{}
{
    try {
        <TRUE> <RESULT> <OPENBRACKET> lista_comandos(g) <CLOSEBRACKET> (selecao_untrue(g))?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void selecao_untrue(RecoverySet g) throws ParseException:
{}
{
    try {
        <UNTRUE> <RESULT> <OPENBRACKET> lista_comandos(g) <CLOSEBRACKET> (selecao_true(g))?
    } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void comando_repeticao(RecoverySet g) throws ParseException:
{}
{
    try {
        <REPEAT> <THIS> expression(g) <OPENBRACKET> lista_comandos(g) <CLOSEBRACKET> <DOT>
  } catch (ParseException e) {
        output.add(new Message(ErrorMessage.getErrorMessage(e), true));
    }
}

void expression(RecoverySet g) : {} 
{	
	try {
		expression_arith_or_logic(g) expression_(g)
	} catch (ParseException e) {
		consumeUntil(g, e, "expression");
                output.add(new Message(ErrorMessage.getErrorMessage(e), true));
	}
}

void expression_(RecoverySet g) : {}
{
	<EQUALS> expression_arith_or_logic(g) |
	<DIFFERENT> expression_arith_or_logic(g) |
	<LESS> expression_arith_or_logic(g) |
	<GREATER> expression_arith_or_logic(g) |
	<LESSEQUAL> expression_arith_or_logic(g) |
	<GREATEREQUAL> expression_arith_or_logic(g) |
	{}
}

void expression_arith_or_logic(RecoverySet g) : {}
{
	term2(g) less_priority(g)
}

void less_priority(RecoverySet g) : {} 
{
	<PLUS> term2(g) less_priority(g) |
	<MINUS> term2(g) less_priority(g) |
	<PIPE> term2(g) less_priority(g) |
	{}
}

void term2(RecoverySet g) : {}
{
	term1(g) med_priority(g)
}

void med_priority(RecoverySet g) : {}
{
	<MULTIPLY> term1(g) med_priority(g) |
	<FRACTION> term1(g) med_priority(g) |
	<PERCENT> term1(g) med_priority(g) |
	<MOD> term1(g) med_priority(g) |
	<AMPERSAND> term1(g) med_priority(g) |
	{}
}

void term1(RecoverySet g) : {}
{
	element(g) high_priority()
}

void high_priority() : {}
{
	<POTENCY> high_priority() |
	{}
}

void element(RecoverySet g) : {} 
{
	<IDENTIFICADOR> index() |
	<CONSTANTE_NUM_INTEIRA> |
	<CONSTANTE_NUM_REAL> |
	<CONSTANTE_LITERAL> |
	<TRUE> |
	<UNTRUE> |
	<OPENPARENTHESIS> expression(g) <CLOSEPARENTHESIS> |
	<EXCLAMATION> <OPENPARENTHESIS> expression(g) <CLOSEPARENTHESIS>
}

void index() : {} 
{
	LOOKAHEAD(2) <OPENBRACKET> <CONSTANTE_NUM_INTEIRA> <CLOSEBRACKET> |
	{}
}

//------------------------------------------------------------- lexico - m1 - inicio ------------------------------------------------------------------
//CHARACTERS TO SCAPE

SKIP : {
          " "
	| "\t"
        | "\n"
        | "\r"
        | "\f"
}

SKIP : {
    "##": multilinecomment
}

SKIP : {
    "//": singlelinecomment
}

<multilinecomment> SKIP : {
	"#": DEFAULT
	| <~[]>
}

<singlelinecomment> SKIP : {
	<["\n", "\r"]> : DEFAULT
	| <~[]>
}

//INTEGER / FLOAT TOKENS
TOKEN : {
    <CONSTANTE_NUM_INTEIRA: <DIGIT>(<DIGIT>)?(<DIGIT>)?(<DIGIT>)?>
	| <CONSTANTE_NUM_REAL: <DIGIT>(<DIGIT>)?(<DIGIT>)?(<DIGIT>)?(<DIGIT>)?<DOT><DIGIT>(<DIGIT>)?(<DIGIT>)?>
	| <#DIGIT: ["0"-"9"]>
}

//RESERVED WORDS
TOKEN [IGNORE_CASE]: {
          <DO: "do">
	| <THIS: "this">
        | <BODY: "body">
	| <DESCRIPTION: "description">
	| <DECLARATION: "declaration">
	| <TYPE: "type">
	| <IS: "is">
	| <CONSTANT: "constant">
	| <AND: "and">
        | <VARIABLE: "variable">  
	| <AS: "as">
	| <INTEGER: "integer">
	| <REAL: "real">
	| <STRING: "string">
	| <LOGIC: "logic">
	| <DESIGNATE: "designate">
	| <TO: "to">
	| <READ: "read">
	| <WRITE: "write">
	| <ALL: "all">
        | <REPEAT: "repeat">
        | <TRUE: "true">
        | <UNTRUE: "untrue">
        | <RESULT: "result">
        //------- isso pode vir a sair.. linguagem anterior ---------------------------
        | <NOT: "not">
        //-------- acaba aqui ---------------------------------------------------------
        | <AVALIATE: "avaliate">

}


//SPECIAL SYMBOLS
TOKEN : {
     < OPENBRACKET: "["> 
	| < CLOSEBRACKET: "]">
	| <DOT: ".">
	| < COMMA: ",">
	| < ASSIGNMENT: "=">
	| < PLUS: "+">
	| < MINUS: "-">
	| < MULTIPLY: "*">
	| < FRACTION: "/">
	| < POTENCY: "**">
	| < PERCENT: "%">
	| < MOD: "%%">
	| < EQUALS: "==">
        | < DIFFERENT: "!=">
	| < LESS: "<<">
	| < GREATER: ">>">
	| < LESSEQUAL: "<<=">
	| < GREATEREQUAL: ">>=">
	| < AMPERSAND: "&">	
	| < PIPE: "|">
	| < EXCLAMATION: "!">	
	| < OPENPARENTHESIS: "(">
	| < CLOSEPARENTHESIS: ")">

}

TOKEN : //Global
{
    < #LETTER_ID: ["A"-"Z", "a"-"z"] >
    | < #LETTER_UPPER: ["A"-"Z"] >
    | < #LETTER_LOWER: ["a"- "z"] >
    | < #DIGIT_ID: ["0"-"9"] >
    | < #SYMBOL_UND: ["_"] >
}

TOKEN : // Identificadores
{
    <IDENTIFICADOR: (<LETTER_UPPER>)(<SYMBOL_UND>)?((<LETTER_ID>(<SYMBOL_UND>)?)|(<DIGIT_ID>(<DIGIT_ID>)?(<LETTER_ID>|<SYMBOL_UND>|(<LETTER_ID>)<SYMBOL_UND>)))*>                    
}

TOKEN :
{
<IDENTIFICADOR_INVALIDO:
                                 (<DIGIT_ID>)+((<LETTER_ID>(<DIGIT_ID>)?(<DIGIT_ID>)?)|<SYMBOL_UND>(<DIGIT_ID>)?(<DIGIT_ID>)?)+ //COMECA COM DIGITO    
                                | ((<LETTER_ID>|<SYMBOL_UND>)(<DIGIT_ID>)?(<DIGIT_ID>)?)+ (<DIGIT_ID>)+ //TERMINA COM DIGITO
                                | (<LETTER_ID>|<SYMBOL_UND>)+ (<DIGIT_ID><DIGIT_ID><DIGIT_ID>) ((<LETTER_ID>)+|<SYMBOL_UND>|<DIGIT_ID>)* // DIGITOS CONSECUTIVOS
                                | (<LETTER_ID>|<SYMBOL_UND>|<DIGIT_ID>)* (<SYMBOL_UND><SYMBOL_UND>) (<LETTER_ID>|<SYMBOL_UND>|<DIGIT_ID>)* //SIMBOLOS CONSECUTIVOS
                                | (<SYMBOL_UND>)(<LETTER_ID>|<SYMBOL_UND>|<DIGIT_ID>)* // INICIANDO COM _     
                                | (<LETTER_LOWER>)(<LETTER_ID>|<SYMBOL_UND>|<DIGIT_ID>)* // INCIANDO COM MINUSCULA
                                

>  

}   

// CONSTANTE LITERAL TOKEN
TOKEN: {
   <CONSTANTE_LITERAL: "\"" (~[ "\"", "\n" ])* "\""> 
}


TOKEN :
{
    <CONSTANTE_NUM_INTEIRA_INVALIDA: ((<DIGIT>){4}(<DIGIT>)+) >
    | <CONSTANTE_NUM_REAL_INVALIDA:   ((<DIGIT>){5}(<DIGIT>)+)(<DOT>) (<DIGIT>)*
                                    | (((<DIGIT>){5})+(<DOT>)((<DIGIT>)(<DIGIT>)(<DIGIT>)+)*)
                                    | (((<DIGIT>){4})+(<DOT>)((<DIGIT>)(<DIGIT>)(<DIGIT>)+)*) 
                                    | (((<DIGIT>){3})+(<DOT>)((<DIGIT>)(<DIGIT>)(<DIGIT>)+)*) 
                                    | (((<DIGIT>){2})+(<DOT>)((<DIGIT>)(<DIGIT>)(<DIGIT>)+)*) 
                                    | ((<DIGIT>)+(<DOT>)((<DIGIT>)(<DIGIT>)(<DIGIT>)+)*) >

    | <CONSTANTE_LITERAL_INVALIDA: "\"" (~["\n","\r","\""])* ~["\""]
                                            | "\'" (~["\n","\r","\'"])* ~["\'"]|"'">
    
    | <COMENTARIO_BLOCO_INVALIDO: "##" (~["#"])* >
    | <COMENTARIO_BLOCO: "##" (~["#"])* "#">
}

TOKEN :
{
    < SIMBOLO_INVALIDO : (~ [
		"a"-"z",
		"A"-"Z",
		"0"-"9",
		"[",
		"]",
		"=",
		".",
		"/",
		"(",
		")",
		"+",
		"-",
		"*",
		"%",
		"=",
		"!",
		"<",
		">",
		"&",
		"|",
		"!",   
		" ",
		"\t",
		"\n",
		"\r",
		"\f"
    ])+ > 
}